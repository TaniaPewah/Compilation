%{
	#include "hw3_output.hpp"
	#include "parserAdapter.hpp"

	using namespace std;
	using namespace output;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
%}


%token BOOL VOID INT BYTE B
%token TRUE FALSE
%token WHILE RETURN
%token BREAK CONTINUE
%token SC COMMA
%token STRING ID NUM

%right ASSIGN

%nonassoc NO_ELSE
%nonassoc ELSE
%right IF
%left OR
%left AND
%left RELOPLEFT
%nonassoc RELOPNOTASS


%left ADDITIVE 
%left MUL

%right NOT


%left LPAREN RPAREN LBRACE RBRACE

%%

Program : INIT Funcs { 
	symbolTable.closeScope();
	printProductionRule(1); }
		;
INIT : NEWSCOPECREATION {
	// TODO create funcNode print, printi

	// symbolTable.addSymbolFunc( print );
	// 
}

Funcs :  %empty { printProductionRule(2); }
	  | FuncDecl Funcs { 
		  printProductionRule(3); }
	  ;

FuncDecl : RetType ID {
			// add function to global scope
			// open new scope
		}
		// check if ID exist if so- thow error
        LPAREN Formals RPAREN {

			cout << "in func decl Formals" << endl;
	
			//TODO: funcDecl scope - the function given parameters should be in the same block as the function itself (after statments),
			// open new scope?

			cout << "in func decl Formals - type name " << ((TypeNode*)$1)->type_name <<endl;
			cout << "in func decl Formals - id node id " << ((IdNode*)$2) -> name << endl;
			cout << "in func decl Formals - params " << ((((FormalsList*)((Formals*)$5)->params)->functionParams).empty())<< endl;
			
			$$ = ruleFuncDecl((IdNode*)$2, ((TypeNode*)$1)->type_name, ((FormalsList*)((Formals*)$5)->params)->functionParams );
			printProductionRule(4);

		} LBRACE Statements RBRACE {

		//TODO: CloseFunctionScope
		}
		;

RetType : Type { 
		$$ = (TypeNode*)$1;
		printProductionRule(5); }
		| VOID { 
			$$ = (TypeNode*)$1;	
			printProductionRule(6); }
		;

Formals :  %empty { 

	$$ = new Formals();
	printProductionRule(7); }
    | FormalsList { 

		$$ = new Formals((FormalsList*)$1);

		// create params empty vector
		
		printProductionRule(8); }
    ;

FormalsList : FormalDecl { 
	// varNode $1 addParam
	$$ = ruleAddFormals( (FormalsList*)ruleCreateFormals( ((VarNode*)$1)->lineno ), (VarNode*)$1); 
	
	printProductionRule(9); }
			| FormalDecl COMMA FormalsList { 
				
				$$ = ruleAddFormals((FormalsList*)$3, (VarNode*)$1);
				printProductionRule(10); }
			;

FormalDecl : Type ID { 
	$$ = ruleVarDecl(((TypeNode*)$1)->type_name, (IdNode*)$2); 
	printProductionRule(11); };
Statements : Statement {
				printProductionRule(12); }
		   | Statements Statement { 
				printProductionRule(13);}
		   ;

Statement : LBRACE NEWSCOPECREATION Statements RBRACE { 
			symbolTable.closeScope();
			printProductionRule(14); }
		  | Type ID SC { // add ID to symbolTable $1 is the type
		  
		  					$$ = ruleVarDecl(((TypeNode*)$1)->type_name, (IdNode*)$2);
		                    printProductionRule(15); }

		  | Type ID ASSIGN Exp SC { 
									$$ = ruleVarDeclAssign( (IdNode*)$2, 
														   ((TypeNode*)$1)->type_name, 
														   ((ExpNode*)$4)->type);
		                            printProductionRule(16); }

		  | ID ASSIGN Exp SC { 
			  ruleIdAssign((IdNode*)$1 , (ExpNode*)$3);
			  printProductionRule(17); }
		  | Call SC { printProductionRule(18); }
		  | RETURN SC { printProductionRule(19); }
		  | RETURN Exp SC { printProductionRule(20); }
		  | IfScope %prec NO_ELSE { 
			  printProductionRule(21); }

          | IfScope ELSE NEWSCOPECREATION Statement { 
			  symbolTable.closeScope();
			  printProductionRule(22); }

		  |  whileScope %prec NO_ELSE { 
			  printProductionRule(23); }

		  | whileScope ELSE NEWSCOPECREATION Statement { 
			  symbolTable.closeScope();
			  printProductionRule(24); }

		  | BREAK SC { printProductionRule(25); }
		  | CONTINUE SC { printProductionRule(26); }
		  ;

IfScope : IF LPAREN NEWSCOPECREATION Exp RPAREN Statement {
	symbolTable.closeScope();
}
;

whileScope : WHILE LPAREN NEWSCOPECREATION Exp RPAREN Statement {
	symbolTable.closeScope();
}
;

Call : ID LPAREN ExpList RPAREN { 
		 $$ = ruleCallFunc((IdNode*)$1);
	printProductionRule(27); }
	
	 | ID LPAREN RPAREN { 
		$$ = ruleCallFunc((IdNode*)$1);
	 	printProductionRule(28); }
	 ;

ExpList : Exp { printProductionRule(29); }
		| Exp COMMA ExpList { printProductionRule(30); }
		;


Type	: INT { printProductionRule(31); }
		| BYTE { printProductionRule(32); }
		| BOOL { printProductionRule(33); }
		;

Exp : LPAREN Exp RPAREN { 
		$$ = (ExpNode*)$2;
		cout<<"current node type is :" <<((ExpNode*)$$)->type << endl;
		printProductionRule(34); }
	| Exp ADDITIVE Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| Exp MUL Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| ID { 
		printProductionRule(36); }
	| Call {
		printProductionRule(37); }
	| NUM { 
		$$ = ruleExpNum((NumNode*)$1);
		printProductionRule(38); }
	| NUM B { 
		$$ = (ruleExpNumB((NumNode*)$1));
		printProductionRule(39); }
	| STRING { $$ = (ExpNode*)$1;
		printProductionRule(40); }
	| TRUE { $$ = (ExpNode*)$1;
		printProductionRule(41); }
	| FALSE { $$ = (ExpNode*)$1;
		printProductionRule(42); }
	| NOT Exp { 
		$$ = ruleNotExp((ExpNode*)$2);
		printProductionRule(43); }
	| Exp AND Exp { printProductionRule(44); }
	| Exp OR Exp { printProductionRule(45); }
	| Exp RELOPLEFT Exp { 
		
		// check both Exp are numerical
		$$ = ruleRelop((ExpNode*)$1, (ExpNode*)$3);
		//
		
		printProductionRule(46); }
    | Exp RELOPNOTASS Exp { printProductionRule(46); }
	;

NEWSCOPECREATION :  %empty { symbolTable.newScope(); };

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn( yylineno );
	exit(0);
}
