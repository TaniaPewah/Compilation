%{
	#include "hw3_output.hpp"
	#include "parserAdapter.hpp"

	using namespace std;
	using namespace output;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
%}


%token BOOL VOID INT BYTE B
%token TRUE FALSE
%token WHILE RETURN
%token BREAK CONTINUE
%token SC COMMA
%token STRING ID NUM

%right ASSIGN

%nonassoc NO_ELSE
%nonassoc ELSE
%right IF
%left OR
%left AND
%left RELOPLEFT
%nonassoc RELOPNOTASS


%left ADDITIVE 
%left MUL

%right NOT


%left LPAREN RPAREN LBRACE RBRACE

%%

Program : INIT Funcs { printProductionRule(1); }
		;
INIT : { symbolTable.newScope();
		}

Funcs : { printProductionRule(2); }
	  | FuncDecl Funcs { 
		  printProductionRule(3); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {
        // add ID to symbolTable $2 is the name of function
        // $$ = new FuncDefinition($2, offset, $1, $4 )

		$$ = ruleFuncDecl((IdNode*)$2);
        printProductionRule(4); }
		;

RetType : Type { printProductionRule(5); }
		| VOID { printProductionRule(6); }
		;

Formals :  { printProductionRule(7); }
    | FormalsList { printProductionRule(8); }
    ;

FormalsList : FormalDecl { printProductionRule(9); }
			| FormalDecl COMMA FormalsList { printProductionRule(10); }
			;

FormalDecl : Type ID { printProductionRule(11); };
Statements : Statement { printProductionRule(12); }
		   | Statements Statement { 
			   printProductionRule(13);}
		   ;

Statement : LBRACE Statements RBRACE { printProductionRule(14); }
		  | Type ID SC { // add ID to symbolTable $1 is the type
		  
		  					$$ = ruleVarDecl((IdNode*)$2);
		                    printProductionRule(15); }

		  | Type ID ASSIGN Exp SC { // add ID to symbolTable $1 is the type
		                            
									// TODO: take care of the type
									$$ = ruleVarDeclAssign( (IdNode*)$2, 
														   ((TypeNode*)$1)->type_name, 
														   ((ExpNode*)$4)->type);
		                            printProductionRule(16); }

		  | ID ASSIGN Exp SC { printProductionRule(17); }
		  | Call SC { printProductionRule(18); }
		  | RETURN SC { printProductionRule(19); }
		  | RETURN Exp SC { printProductionRule(20); }
		  | IF LPAREN Exp RPAREN Statement %prec NO_ELSE { printProductionRule(21); }
          | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(22); }
		  | WHILE LPAREN Exp RPAREN Statement %prec NO_ELSE { printProductionRule(23); }
		  | WHILE LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(24); }
		  | BREAK SC { printProductionRule(25); }
		  | CONTINUE SC { printProductionRule(26); }
		  ;

Call : ID LPAREN ExpList RPAREN { printProductionRule(27); }
	 | ID LPAREN RPAREN { printProductionRule(28); }
	 ;

ExpList : Exp { printProductionRule(29); }
		| Exp COMMA ExpList { printProductionRule(30); }
		;


Type	: INT { printProductionRule(31); }
		| BYTE { printProductionRule(32); }
		| BOOL { printProductionRule(33); }
		;

Exp : LPAREN Exp RPAREN { 
		$$ = (ExpNode*)$2;
		printProductionRule(34); }
	| Exp ADDITIVE Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| Exp MUL Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| ID { 
		printProductionRule(36); }
	| Call { printProductionRule(37); }
	| NUM { 
		$$ = ruleExpNum((NumNode*)$1);
		printProductionRule(38); }
	| NUM B { 
		$$ = (ruleExpNumB((NumNode*)$1));
		printProductionRule(39); }
	| STRING { printProductionRule(40); }
	| TRUE { $$ = (ExpNode*)$1;
		printProductionRule(41); }
	| FALSE { printProductionRule(42); }
	| NOT Exp { printProductionRule(43); }
	| Exp AND Exp { printProductionRule(44); }
	| Exp OR Exp { printProductionRule(45); }
	| Exp RELOPLEFT Exp { printProductionRule(46); }
    | Exp RELOPNOTASS Exp { printProductionRule(46); }
	;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn( yylineno );
	exit(0);
}
