%{
	#include "hw3_output.hpp"
	#include "parser.hpp"
	#include "symbolTable.h"

	using namespace std;
	using namespace output;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
	SymbolTable symbolTable;
%}


%token BOOL VOID INT BYTE B
%token TRUE FALSE
%token WHILE RETURN
%token BREAK CONTINUE
%token SC COMMA
%token STRING ID NUM

%right ASSIGN

%nonassoc NO_ELSE
%nonassoc ELSE
%right IF
%left OR
%left AND
%left RELOPLEFT
%nonassoc RELOPNOTASS




%left ADDITIVE 
%left MUL

%right NOT


%left LPAREN RPAREN LBRACE RBRACE

%%

Program : INIT Funcs { printProductionRule(1); }
		;
INIT : { symbolTable.newScope();
		}

Funcs : { printProductionRule(2); }
	  | FuncDecl Funcs { printProductionRule(3); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {
        // add ID to symbolTable $2 is the name of function
        // $$ = new FuncDefinition($2, offset, $1, $4 )

		string name = ((IdNode*)$2)->name;
		$$ = new IdNode( $2->lineno, name ); 
		symbolTable.addSymbolFunc( (IdNode*)$$ );

        printProductionRule(4); }
		;

RetType : Type { printProductionRule(5); }
		| VOID { printProductionRule(6); }
		;

Formals :  { printProductionRule(7); }
    | FormalsList { printProductionRule(8); }
    ;

FormalsList : FormalDecl { printProductionRule(9); }
			| FormalDecl COMMA FormalsList { printProductionRule(10); }
			;

FormalDecl : Type ID { printProductionRule(11); };
Statements : Statement { printProductionRule(12); }
		   | Statements Statement { printProductionRule(13);}
		   ;

Statement : LBRACE Statements RBRACE { printProductionRule(14); }
		  | Type ID SC { // add ID to symbolTable $1 is the type
		  					string name = ((IdNode*)$2)->name;
		  					$$ = new IdNode($2->lineno, name); 
		  					symbolTable.addSymbolVar( (IdNode*)$$ );
		                    printProductionRule(15); }

		  | Type ID ASSIGN Exp SC { // add ID to symbolTable $1 is the type
		                            // $$ = new VarDefinition($2, counter, $1)
									string name = ((IdNode*)$2)->name;

									$$ = new IdNode( $2->lineno, name );
									delete((IdNode*)$2); 
		  							symbolTable.addSymbolVar( (IdNode*)$$ );
		                            printProductionRule(16); }


		  | ID ASSIGN Exp SC { printProductionRule(17); }
		  | Call SC { printProductionRule(18); }
		  | RETURN SC { printProductionRule(19); }
		  | RETURN Exp SC { printProductionRule(20); }
		  | IF LPAREN Exp RPAREN Statement %prec NO_ELSE { printProductionRule(21); }
          | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(22); }
		  | WHILE LPAREN Exp RPAREN Statement %prec NO_ELSE { printProductionRule(23); }
		  | WHILE LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(24); }
		  | BREAK SC { printProductionRule(25); }
		  | CONTINUE SC { printProductionRule(26); }
		  ;

Call : ID LPAREN ExpList RPAREN { printProductionRule(27); }
	 | ID LPAREN RPAREN { printProductionRule(28); }
	 ;

ExpList : Exp { printProductionRule(29); }
		| Exp COMMA ExpList { printProductionRule(30); }
		;


Type	: INT { printProductionRule(31); }
		| BYTE { printProductionRule(32); }
		| BOOL { printProductionRule(33); }
		;

Exp : LPAREN Exp RPAREN { printProductionRule(34); }
	| Exp ADDITIVE Exp { printProductionRule(35); }
	| Exp MUL Exp { printProductionRule(35); }
	| ID { printProductionRule(36); }
	| Call { printProductionRule(37); }
	| NUM { 
	        printProductionRule(38); }
	| NUM B { printProductionRule(39); }
	| STRING { printProductionRule(40); }
	| TRUE { printProductionRule(41); }
	| FALSE { printProductionRule(42); }
	| NOT Exp { printProductionRule(43); }
	| Exp AND Exp { printProductionRule(44); }
	| Exp OR Exp { printProductionRule(45); }
	| Exp RELOPLEFT Exp { printProductionRule(46); }
    | Exp RELOPNOTASS Exp { printProductionRule(46); }
	;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn( yylineno );
	exit(0);
}
