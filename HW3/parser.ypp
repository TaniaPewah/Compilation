%{
	#include "hw3_output.hpp"
	#include "parserAdapter.hpp"

	using namespace std;
	using namespace output;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
%}


%token BOOL VOID INT BYTE B
%token TRUE FALSE
%token WHILE RETURN
%token BREAK CONTINUE
%token SC COMMA
%token STRING ID NUM

%right ASSIGN

%nonassoc NO_ELSE
%nonassoc ELSE
%right IF
%left OR
%left AND
%left RELOPLEFT
%nonassoc RELOPNOTASS


%left ADDITIVE 
%left MUL

%right NOT


%left LPAREN RPAREN LBRACE RBRACE

%%

Program : INIT Funcs { 
	symbolTable.closeScope();
	printProductionRule(1); }
		;
INIT : NEWSCOPECREATION {
	// TODO create funcNode print, printi

	// symbolTable.addSymbolFunc( print );
	// 
}

Funcs : { printProductionRule(2); }
	  | FuncDecl Funcs { 
		  printProductionRule(3); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {
		//TODO: funcDecl scope- the function givven parameters should be in the same block as the function itself (after statments),
		// Whith a negative sign

        // add ID to symbolTable $2 is the name of function
        // $$ = new FuncDefinition($2, offset, $1, $4 )

		// TODO: newFunctioScope($4, $7);
		//TODO: CloseFunctionScope

		$$ = ruleFuncDecl((IdNode*)$2);
        printProductionRule(4); }
		;

RetType : Type { printProductionRule(5); }
		| VOID { printProductionRule(6); }
		;

Formals :  { printProductionRule(7); }
    | FormalsList { printProductionRule(8); }
    ;

FormalsList : FormalDecl { printProductionRule(9); }
			| FormalDecl COMMA FormalsList { printProductionRule(10); }
			;

FormalDecl : Type ID { printProductionRule(11); };
Statements : Statement {
				printProductionRule(12); }
		   | Statements Statement { 
				printProductionRule(13);}
		   ;

Statement : LBRACE NEWSCOPECREATION Statements RBRACE { 
			symbolTable.closeScope();
			printProductionRule(14); }
		  | Type ID SC { // add ID to symbolTable $1 is the type
		  
		  					$$ = ruleVarDecl(((TypeNode*)$1)->type_name, (IdNode*)$2);
		                    printProductionRule(15); }

		  | Type ID ASSIGN Exp SC { // add ID to symbolTable $1 is the type
		                            
									// TODO: take care of the type
									$$ = ruleVarDeclAssign( (IdNode*)$2, 
														   ((TypeNode*)$1)->type_name, 
														   ((ExpNode*)$4)->type);
		                            printProductionRule(16); }

		  | ID ASSIGN Exp SC { printProductionRule(17); }
		  | Call SC { printProductionRule(18); }
		  | RETURN SC { printProductionRule(19); }
		  | RETURN Exp SC { printProductionRule(20); }
		  | IfScope %prec NO_ELSE { 
			  printProductionRule(21); }

          | IfScope ELSE NEWSCOPECREATION Statement { 
			  symbolTable.closeScope();
			  printProductionRule(22); }

		  |  whileScope %prec NO_ELSE { 
			  printProductionRule(23); }

		  | whileScope ELSE NEWSCOPECREATION Statement { 
			  symbolTable.closeScope();
			  printProductionRule(24); }

		  | BREAK SC { printProductionRule(25); }
		  | CONTINUE SC { printProductionRule(26); }
		  ;

IfScope : IF LPAREN NEWSCOPECREATION Exp RPAREN Statement {
	symbolTable.closeScope();
}
;

whileScope : WHILE LPAREN NEWSCOPECREATION Exp RPAREN Statement {
	symbolTable.closeScope();
}
;

Call : ID LPAREN ExpList RPAREN { 
		 $$ = ruleCallFunc((IdNode*)$1);
	printProductionRule(27); }
	
	 | ID LPAREN RPAREN { 
		$$ = ruleCallFunc((IdNode*)$1);
	 	printProductionRule(28); }
	 ;

ExpList : Exp { printProductionRule(29); }
		| Exp COMMA ExpList { printProductionRule(30); }
		;


Type	: INT { printProductionRule(31); }
		| BYTE { printProductionRule(32); }
		| BOOL { printProductionRule(33); }
		;

Exp : LPAREN Exp RPAREN { 
		$$ = (ExpNode*)$2;
		printProductionRule(34); }
	| Exp ADDITIVE Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| Exp MUL Exp { 
		$$ = ruleExpBinopExp((ExpNode*)$1, (BinopNode*)$2, (ExpNode*)$3);
		printProductionRule(35); }
	| ID { 
		printProductionRule(36); }
	| Call {
		cout << "!!!!!!!!!!!!!!!!!!!!!Exp - >call here " << endl;
		printProductionRule(37); }
	| NUM { 
		$$ = ruleExpNum((NumNode*)$1);
		printProductionRule(38); }
	| NUM B { 
		$$ = (ruleExpNumB((NumNode*)$1));
		printProductionRule(39); }
	| STRING { $$ = (ExpNode*)$1;
		printProductionRule(40); }
	| TRUE { $$ = (ExpNode*)$1;
		printProductionRule(41); }
	| FALSE { $$ = (ExpNode*)$1;
		printProductionRule(42); }
	| NOT Exp { printProductionRule(43); }
	| Exp AND Exp { printProductionRule(44); }
	| Exp OR Exp { printProductionRule(45); }
	| Exp RELOPLEFT Exp { printProductionRule(46); }
    | Exp RELOPNOTASS Exp { printProductionRule(46); }
	;

NEWSCOPECREATION : { symbolTable.newScope(); };

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn( yylineno );
	exit(0);
}
